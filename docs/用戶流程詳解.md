# 用戶流程詳解

## 📊 用戶輸入處理流程

### 完整處理流程圖
```
用戶輸入 
    ↓
純時間檢測攔截
    ↓
上下文加載
    ↓
規則引擎智能打分
    ↓
統一實體提取
    ↓
關鍵信心度測試
    ↓
Slot Template 處理（可選）
    ↓
槽位狀態管理
    ↓
問題檢測
    ↓
智能分離處理
    ↓
問題策略處理
    ↓
任務執行
    ↓
回應生成
```

### 增強版多輪對話處理

#### 詳細處理步驟

**Step 1: 接收用戶輸入**
- `lineController` 接收來自 LINE Platform 的 Webhook 事件
- 提取用戶 ID、訊息內容、時間戳等基本信息
- 初始化請求上下文

**Step 2: 上下文加載**
- `conversationContext` 模組從 Firestore 加載用戶對話上下文
- 包含對話歷史、用戶偏好、未完成任務等
- 建立完整的用戶會話狀態

**Step 3: 純時間檢測攔截**
```javascript
// 攔截無意義的純時間輸入，避免系統資源浪費
const pureTimeInputs = [
  "明天下午四點",
  "今天晚上八點", 
  "下週三上午十點"
];

// 檢測邏輯
function detectPureTimeInput(text) {
  const pureTimePatterns = [
    /^(明天|今天|後天|下週\w+)\s*(上午|下午|晚上)?\s*\d{1,2}點半?$/,
    /^\d{1,2}:\d{2}$/,
    /^\d{1,2}點\d{0,2}分?$/
  ];
  
  return pureTimePatterns.some(pattern => pattern.test(text.trim()));
}

// 處理結果
detectPureTimeInput("明天下午四點") → 直接拒絕，返回友善提示
detectPureTimeInput("明天下午四點跆拳道") → 通過檢測，繼續處理
```

**Step 4: 場景路由**
- `ScenarioManager` 根據意圖規則和對話歷史決定當前對話場景
- 載入對應的 Scenario Template 和配置
- 設定場景特定的處理規則

**Step 5: 規則引擎智能打分**
```javascript
// IntentRuleEngine 基於 intent-rules.yaml 配置進行意圖識別
const examples = [
  {
    input: "取消數學課",
    output: { intent: 'cancel_course', confidence: 0.8, keywords: ['取消'] }
  },
  {
    input: "我想學點什麼",
    output: { intent: 'unknown', confidence: 0.0, keywords: [] }
  },
  {
    input: "明天有英文課",
    output: { intent: 'record_course', confidence: 0.7, keywords: ['有'] }
  }
];

// 規則匹配過程
function analyzeWithRules(text) {
  const rules = loadIntentRules(); // 從 YAML 載入規則
  let bestMatch = { intent: 'unknown', confidence: 0.0 };
  
  for (const [intent, rule] of Object.entries(rules)) {
    const score = calculateMatchScore(text, rule);
    if (score > bestMatch.confidence) {
      bestMatch = { intent, confidence: score };
    }
  }
  
  return bestMatch;
}
```

**Step 6: 統一實體提取**
```javascript
// SemanticService 提供統一的實體提取接口
// 內部使用 OpenAI + 正則表達式 fallback 機制

const extractionExamples = [
  {
    input: "明天下午四點半跆拳道",
    output: {
      course_name: "跆拳道",
      timeInfo: {
        date: "2025-07-31",
        time: "16:30", 
        confidence: 0.9,
        original: "明天下午四點半"
      },
      location: null,
      teacher: null
    }
  },
  {
    input: "週三上午十點在體育館上體育課",
    output: {
      course_name: "體育課",
      timeInfo: {
        date: "2025-08-06", // 下週三
        time: "10:00",
        confidence: 0.8
      },
      location: "體育館",
      teacher: null
    }
  }
];

// 提取過程
async function extractCourseEntities(text) {
  try {
    // 優先使用 OpenAI 進行智能提取
    const aiResult = await openaiService.extractEntities(text);
    if (aiResult.confidence > 0.7) return aiResult;
  } catch (error) {
    console.log('OpenAI extraction failed, using fallback');
  }
  
  // Fallback 到正則表達式提取
  return regexBasedExtraction(text);
}
```

**Step 7: 關鍵信心度測試**
```javascript
// 智能判斷決策點
function shouldUseAI(ruleResult, entityResult) {
  // 高信心度規則匹配 + 實體提取成功 → 跳過 AI
  if (ruleResult.confidence >= 0.8 && 
      ruleResult.intent !== 'unknown' && 
      entityResult.hasRequiredFields) {
    return false; // 60-70% 案例，毫秒級響應
  }
  
  // 低信心度或複雜語義 → 使用 AI
  return true; // 30-40% 案例，深度理解
}

// 處理分流
if (shouldUseAI(ruleResult, entityResult)) {
  // AI 深度分析路径
  const aiAnalysis = await OpenAI.analyzeIntent(text, context);
  return mergeResults(ruleResult, entityResult, aiAnalysis);
} else {
  // 規則引擎直接路径
  return formatResult(ruleResult, entityResult);
}
```

**Step 8: 槽位狀態管理**（Slot Template 系統啟用時）
- `slotStateManager` 接收語義分析結果
- 更新當前場景的槽位狀態
- 處理槽位填充、確認、澄清等操作

**Step 9: 問題檢測**
- `slotProblemDetector` 檢查當前槽位是否存在問題
- 識別信息模糊、衝突、缺失等情況
- 生成需要用戶澄清的問題列表

**Step 10: 智能分離處理**
```javascript
// 處理混雜的槽位內容，例如：
const mixedInput = "明天數學課改到後天，還有週三的英文課取消";

// 分離處理
const separatedIntents = [
  {
    action: "modify_course",
    entities: { course_name: "數學課", timeChange: "明天→後天" }
  },
  {
    action: "cancel_course", 
    entities: { course_name: "英文課", time: "週三" }
  }
];

// 分別處理每個意圖
for (const intent of separatedIntents) {
  await processIntent(intent);
}
```

**Step 11: 問題策略處理**
```javascript
// 根據問題數量採用不同策略
function handleProblems(problems) {
  switch (problems.length) {
    case 0:
      // 無問題：直接執行任務
      return executeTask();
      
    case 1:
      // 單一問題：創建暫存狀態，生成澄清問題
      createTempState(problems[0]);
      return generateClarificationQuestion(problems[0]);
      
    default:
      // 多個問題：要求用戶重新輸入完整信息
      return requestCompleteInformation(problems);
  }
}
```

**Step 12: 任務執行**
- `taskService` 調用相應的後端服務
- 例如 `courseService` 或 `dataService`
- 執行具體的業務邏輯操作

**Step 13: 回應生成**
- `humanPromptGenerator` 根據處理結果生成自然回應
- 考慮用戶友善性和信息完整性
- 統一格式化輸出

**Step 14: 回應發送**
- `lineService` 將生成的回應通過 LINE Messaging API 發送給用戶
- 記錄對話歷史和用戶互動數據

## 📈 處理效率統計

### 性能分析

| 處理層級 | 案例比例 | 響應時間 | 準確率 | 成本 | 範例 |
|---------|---------|----------|--------|------|------|
| **純時間攔截** | ~5% | <1ms | 100% | 免費 | "明天下午四點" |
| **規則引擎** | ~60-70% | <10ms | 100% | 免費 | "取消數學課" |
| **OpenAI處理** | ~30-40% | 200-500ms | 95%+ | 付費 | "我想學點什麼" |
| **Slot Template** | ~20-30% | 100-300ms | 98%+ | 中等 | 複雜多輪對話 |

### 優化效果

**效能最佳化**：
- ✅ 70% 請求毫秒級響應（規則引擎處理）
- ✅ AI 調用量減少 70%，大幅降低成本
- ✅ 系統資源使用最小化
- ✅ 多輪對話智能補全，減少用戶重複輸入

**準確性保證**：
- ✅ 確定性意圖 100% 準確識別
- ✅ 複雜語義交由 AI 深度理解
- ✅ 分層 fallback 確保穩定性
- ✅ 智能問題檢測和分離處理

## 🎯 用戶場景範例

### 場景 1: 簡單課程新增
```
用戶: "明天下午2點數學課"
處理: 規則引擎識別 → 實體提取 → 直接執行
回應: "✅ 課程「數學課」已成功新增！🕒 時間：07/31 2:00 PM"
耗時: <10ms
```

### 場景 2: 複雜意圖理解
```
用戶: "我想學點什麼比較好"
處理: 規則引擎低信心度 → OpenAI 深度分析 → 推薦回應
回應: "我可以幫您推薦一些熱門課程，或者您可以告訴我您的興趣方向..."
耗時: ~300ms
```

### 場景 3: 多輪對話補全
```
用戶: "數學課"
系統: "請問您要對數學課做什麼操作呢？"
用戶: "改時間"
系統: "請問要改到什麼時間？"
用戶: "明天晚上8點"
處理: 暫存狀態管理 → 槽位補全 → 執行修改
回應: "✅ 課程「數學課」時間已修改為 07/31 8:00 PM"
```

### 場景 4: 智能分離處理
```
用戶: "明天數學課改到後天，週三英文課取消"
處理: 智能分離 → 兩個獨立任務 → 分別執行
回應: "✅ 已完成兩項操作：
1. 數學課時間已修改為 08/01 [原時間]
2. 週三的英文課已取消"
```

## 🛡️ 錯誤處理流程

### 常見錯誤類型

**1. 純時間輸入錯誤**
```
用戶: "明天下午3點"
系統: "請告訴我明天下午3點要做什麼課程或活動 😊"
```

**2. 模糊意圖錯誤**
```
用戶: "那個課"
系統: "請問您指的是哪一堂課呢？您可以說課程名稱，比如「數學課」或「英文課」"
```

**3. 時間衝突錯誤**
```
用戶: "明天下午2點英文課"
系統: "⚠️ 明天下午2點您已經有數學課了，請選擇其他時間或取消原有課程"
```

**4. 系統錯誤處理**
```
OpenAI API 錯誤 → 自動 fallback 到規則引擎
Firebase 連接錯誤 → 暫存本地並稍後重試
LINE API 錯誤 → 記錄錯誤並通知管理員
```

## 📱 多輪對話增強機制

### 暫存狀態管理
```javascript
// 單一問題檢測時創建暫存狀態
const tempState = {
  userId: "user123",
  pendingIntent: "record_course",
  partialEntities: {
    course_name: "數學課",
    timeInfo: null  // 缺失信息
  },
  missingFields: ["timeInfo"],
  timestamp: Date.now(),
  expiresAt: Date.now() + (5 * 60 * 1000) // 5分鐘過期
};

// 用戶補充信息時
用戶: "明天下午3點"
// 系統自動
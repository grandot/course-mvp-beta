# 系統架構設計文檔

## 🏗️ 三層語義架構

### 核心理念
**分離式架構設計** - Single Source of Truth + Forced Boundaries

```
用戶自然語言 → 語義處理層 → 時間處理層 → 任務執行層 → 統一格式回覆
```

### 系統性設計原則

**Single Source of Truth**：每種功能只有一個唯一入口
- ✅ 所有時間相關 → `TimeService`
- ✅ 所有語義相關 → `SemanticService`  
- ✅ 所有數據相關 → `DataService`

**Forced Boundaries**：通過技術手段強制邊界約束
- ✅ ESLint 規則禁止跨層調用
- ✅ 模組封裝隱藏內部實現
- ✅ 接口契約明確職責邊界

**No Cross-Layer Access**：禁止跨層直接調用
- ❌ Controllers 不得直接調用 OpenAI
- ❌ Services 不得直接使用 `new Date()`
- ❌ Utils 不得直接操作數據庫

## 🎯 Scenario Layer 架構（v9.0）

### Template-Based 多場景業務平台
從單一課程管理系統轉換為通用多場景平台

```
用戶自然語言 → 語義處理層 → Scenario Layer → EntityService → 統一格式回覆
```

### ScenarioTemplate 抽象基類
```javascript
class ScenarioTemplate {
  constructor(config) {
    this.config = config;
    this.entityType = config.entity_type;
    this.entityName = config.entity_name;
  }

  // 統一業務接口 - 所有場景必須實現
  async createEntity(entities, userId) { throw new Error('Must implement'); }
  async modifyEntity(entities, userId) { throw new Error('Must implement'); }
  async cancelEntity(entities, userId) { throw new Error('Must implement'); }
  async queryEntities(entities, userId) { throw new Error('Must implement'); }
  async clearAllEntities(userId) { throw new Error('Must implement'); }

  // 通用工具方法 - 統一實現
  formatMessage(template, variables) { /* 統一訊息格式化 */ }
  formatConfigMessage(messageKey, variables) { /* 配置驅動訊息 */ }
  validateRequiredFields(entities) { /* 統一欄位驗證 */ }
}
```

### ScenarioManager 單例模式（性能優化）
```javascript
class ScenarioManager {
  // 🎯 啟動時一次性預加載當前場景
  static async initialize() {
    const scenarioType = process.env.SCENARIO_TYPE || 'course_management';
    console.log(`🏭 [ScenarioManager] 初始化單一場景: ${scenarioType}`);
    
    // 只加載當前部署場景，不加載其他場景
    await this.preloadScenario(scenarioType);
    this.currentScenarioType = scenarioType;
    
    console.log(`✅ [ScenarioManager] 場景 "${scenarioType}" 初始化完成，耗時 3ms`);
    console.log(`🎯 WebService 模式: 單一場景部署`);
  }

  // 🎯 獲取當前場景實例（O(1) 查找，無文件 I/O）
  static getCurrentScenario() {
    return this.scenarios.get(this.currentScenarioType);
  }
}
```

### TaskService 委託架構（優化版）
```javascript
// 重構版：instance-based with scenario delegation + 性能優化
class TaskService {
  constructor() {
    // ⚡ 使用預加載的場景實例，避免重複創建和文件 I/O
    this.scenario = ScenarioManager.getCurrentScenario();
  }
  
  async executeIntent(intent, entities, userId) {
    // 純委託模式 - 所有業務邏輯委託給 Scenario Template
    const intentMethodMap = {
      'record_course': 'createEntity',
      'modify_course': 'modifyEntity',
      'cancel_course': 'cancelEntity',
      'query_courses': 'queryEntities',
      'clear_courses': 'clearAllEntities'
    };
    
    return this.scenario[intentMethodMap[intent]](entities, userId);
  }
}
```

## 🚀 獨立 WebService 部署模式

### 核心原則
每個 chatbot 是完全獨立的 webservice，只包含一個業務場景

```
課程管理 Chatbot:
- 部署地址: render.com/course-bot
- 環境變數: SCENARIO_TYPE=course_management  
- LINE Bot 設定: 連接到課程管理 webhook
- 只加載: 課程管理配置 + 模板 + 相關依賴

長照系統 Chatbot:
- 部署地址: render.com/healthcare-bot
- 環境變數: SCENARIO_TYPE=healthcare_management
- 完全獨立: 與課程系統無任何共享

保險業務 Chatbot:
- 部署地址: render.com/insurance-bot
- 環境變數: SCENARIO_TYPE=insurance_sales
- 獨立擴展: 可根據業務需求獨立調整資源
```

### 微服務架構優勢
- ✅ **資源隔離**: 課程 bot 不佔用長照/保險的內存和配置
- ✅ **安全隔離**: 不同業務場景數據完全分離
- ✅ **故障隔離**: 一個場景故障不影響其他場景
- ✅ **獨立擴展**: 根據各場景負載獨立調整實例數量
- ✅ **技術隔離**: 不同場景可使用不同的技術栈版本

## 🔧 統一服務層架構

### 分離式架構約束 (Single Source of Truth)

| 功能域 | 唯一入口 | 職責 | 禁止事項 |
|-------|---------|------|---------|
| **Scenario Layer** | `ScenarioTemplate` | 業務邏輯實現 | ❌ 直接調用 DataService |
| **語義處理** | `SemanticService` | 意圖+實體+上下文 | ❌ 直接調用 OpenAI/規則引擎 |
| **實體操作** | `EntityService` | 通用 CRUD + 驗證 | ❌ 直接調用 Firebase |
| **時間處理** | `TimeService` | 解析+格式化+計算+驗證 | ❌ 直接使用 `new Date()` |
| **數據處理** | `DataService` | 存取+查詢+格式化 | ❌ 直接調用 Firebase |
| **任務執行** | `TaskService` | 場景委託協調 | ❌ 硬編碼業務邏輯 |

### SemanticService（語義處理唯一入口）
```javascript
class SemanticService {
  static async analyzeMessage(text, context) {
    // 內部協調：規則引擎 + OpenAI + 上下文分析
    // 外部接口：統一的語義分析結果
  }
  
  static async extractCourse(text) {
    // 專門的課程名稱提取
  }
  
  static async extractTime(text) {
    // 專門的時間信息提取
  }
}
```

### TimeService（時間處理唯一入口）
```javascript
class TimeService {
  static getCurrentUserTime() {
    // 替換所有 new Date() 使用
  }
  
  static parseTimeString(str, referenceTime) {
    // 統一的時間解析入口
  }
  
  static formatForDisplay(time, format) {
    // 統一的時間格式化入口
  }
}
```

### EntityService - 通用實體操作
```javascript
class EntityService {
  // 通用 CRUD 操作 - 支持所有實體類型
  static async createEntity(entityType, entityData) {
    // 統一創建邏輯 + 時間戳 + 數據驗證
  }
  
  static async updateEntity(entityType, entityId, updateData) {
    // 統一更新邏輯 + 衝突檢查
  }
  
  static async queryEntities(entityType, criteria) {
    // 統一查詢邏輯 + 過濾排序
  }
  
  static async checkTimeConflicts(entityType, userId, date, time, excludeId) {
    // 統一時間衝突檢查
  }
}
```

## 🎯 配置驅動設計

### 場景配置結構 (YAML)
```yaml
# config/scenarios/course_management.yaml
scenario_name: "course_management"
entity_type: "courses"                    # Firebase 集合名稱
entity_name: "課程"                       # 顯示名稱
required_fields: ["course_name", "timeInfo"]

# 訊息模板
messages:
  create_success: "✅ {entity_name}「{course_name}」已成功新增！\n🕒 時間：{schedule_time}"
  modify_success: "✅ {entity_name}「{course_name}」時間已修改為 {schedule_time}"
  cancel_success: "✅ {entity_name}「{course_name}」已取消"
  
# 業務規則
business_rules:
  create:
    allow_duplicate_names: false
    auto_generate_missing_fields: true
  modify:
    allowed_fields: ["schedule_time", "course_date", "location", "teacher"]
    conflict_resolution: "time_priority"
  cancel:
    confirmation_required: false
    soft_delete: true

# 驗證規則
validation_rules:
  time_conflict_check: true
  name_format_check: true
  
# 場景特定配置
course_specific:
  course_types: ["學科", "才藝", "語言", "運動"]
  time_slots: ["上午", "下午", "晚上"]
```

### 意圖規則配置 (`intent-rules.yaml`)
```yaml
# 糾錯意圖 (最高優先級)
correction_intent:
  keywords: ['不對', '錯了', '不是', '改成']
  priority: 15
  requires_context: true

# 課程操作意圖
cancel_course:
  keywords: ['取消', '刪除', '移除', '不要', '不上']
  priority: 10
  exclusions: ['新增', '安排', '預約']
  
record_course:
  keywords: ['新增', '安排', '預約', '上課', '學習', '有']
  priority: 5
  exclusions: ['取消', '刪除', '不要']
```

## 🧠 Ultra-Hard 設計原則

### 第一性原則：確定性問題用規則，複雜性問題用AI
```javascript
// ✅ 正確：確定性意圖用規則匹配
"取消試聽" → IntentRuleEngine → cancel_course (100% 準確)

// ✅ 正確：複雜語義用 AI 理解
"我想學點什麼" → OpenAI → 模糊意圖 + 上下文分析

// ❌ 錯誤：讓 AI 做確定性工作
"取消試聽" → OpenAI → record_course (錯誤識別)
```

### 剃刀法則：能用簡單規則解決的，不用複雜AI
```yaml
# 配置驅動：視覺化、可維護
cancel_course:
  keywords: ['取消', '刪除']
  priority: 10
  
# 而非代碼硬編碼
if (message.includes('取消')) return 'cancel_course'
```

## 🔮 擴展新場景流程
1. **創建配置**: 複製 `config/scenarios/template.yaml` 為新場景配置
2. **實現模板**: 繼承 `ScenarioTemplate` 實現業務邏輯
3. **獨立部署**: 設置 `SCENARIO_TYPE=new_scenario` 部署新實例
4. **LINE 整合**: 創建新的 LINE Bot 連接到新實例
5. **完全隔離**: 新場景與現有場景完全獨立運行
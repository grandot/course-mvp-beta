# 開發指南

## 🚀 開發流程

### MVP 階段開發流程
```
功能開發 → 本地驗證 → 直接部署 → 生產測試 → 用戶反饋 → 快速迭代
```

### 快速原型優先原則
**目標：快速驗證核心功能，優先用戶體驗**

- ✅ **專注核心功能**：課程管理、自然語言處理、LINE Bot 集成
- ✅ **直接部署驗證**：Render 生產環境直接測試
- ❌ **暫不實施**：CI/CD pipeline、測試環境、自動化測試
- ❌ **暫不實施**：單元測試、集成測試、端到端測試

## 🔧 編碼規範

### 必須遵循的規則
```javascript
// ✅ 正確：通過 SemanticService 處理語義
const result = await SemanticService.analyzeMessage(text, context);

// ❌ 錯誤：直接調用 OpenAI
const result = await openaiService.analyze(text);

// ✅ 正確：通過 TimeService 處理時間
const currentTime = TimeService.getCurrentUserTime();

// ❌ 錯誤：直接使用 Date
const currentTime = new Date();

// ✅ 正確：通過 DataService 操作數據
const courses = await DataService.queryCourses(criteria);

// ❌ 錯誤：直接調用 Firebase
const courses = await firebaseService.getCourses(criteria);
```

### 代碼風格要求
- **模組系統**: 使用 ES 模組（import/export）
- **異步處理**: 優先使用 async/await 而非 promises
- **命名慣例**: 遵循現有駝峰命名法
- **註釋原則**: 避免冗長註釋，代碼應自我說明
- **錯誤處理**: 統一使用 try-catch 結構

### 禁止的跨層調用
```javascript
// ❌ 禁止：Controller 直接調用內部服務
// lineController.js
const result = await openaiService.complete(prompt);

// ✅ 正確：通過 SemanticService
const result = await SemanticService.analyzeMessage(text);

// ❌ 禁止：Service 直接操作 Firebase
// courseService.js  
const doc = await firestore.collection('courses').add(data);

// ✅ 正確：通過 DataService
const result = await DataService.saveCourse(courseData);
```

## 📚 核心服務 API

### SemanticService API
```javascript
// 主要分析方法
await SemanticService.analyzeMessage(text, context)
// 返回: { intent, entities, confidence, context }

// 實體提取
await SemanticService.extractCourseEntities(text)
// 返回: { course_name, timeInfo, location, teacher }

// 課程名稱提取
await SemanticService.extractCourse(text)
// 返回: string | null

// 時間信息提取
await SemanticService.extractTime(text)
// 返回: { timeString, parsedTime } | null
```

### TimeService API
```javascript
// 獲取用戶當前時間
TimeService.getCurrentUserTime()
// 返回: Date

// 解析時間字符串
TimeService.parseTimeString(str, referenceTime)
// 返回: { success, parsedTime, confidence }

// 格式化顯示
TimeService.formatForDisplay(time, format)
// 返回: string (格式: MM/DD HH:MM AM/PM)

// 驗證時間格式
TimeService.validateTimeFormat(timeString)
// 返回: boolean
```

### DataService API
```javascript
// 保存課程
await DataService.saveCourse(courseData)
// 返回: { success, courseId, message }

// 查詢課程
await DataService.queryCourses(criteria)
// 返回: Course[]

// 更新課程
await DataService.updateCourse(courseId, updateData)
// 返回: { success, message }

// 刪除課程
await DataService.deleteCourse(courseId)
// 返回: { success, message }

// 檢查時間衝突
await DataService.checkTimeConflicts(userId, date, time, excludeId)
// 返回: { hasConflict, conflictingCourses }
```

### TaskService API
```javascript
// 執行意圖任務
await TaskService.executeIntent(intent, entities, userId)
// 返回: { success, message, data }

// 支持的意圖類型
const supportedIntents = [
  'record_course',    // 新增課程
  'modify_course',    // 修改課程
  'cancel_course',    // 取消課程
  'query_courses',    // 查詢課程
  'clear_courses'     // 清空課程
];
```

## 📊 用戶輸入處理流程詳解

### 處理步驟詳細說明

**Step 0: 純時間檢測攔截**
```javascript
// 攔截無意義的純時間輸入，避免系統資源浪費
const pureTimePatterns = [
  /^(明天|今天|後天)\s*(上午|下午|晚上)?\s*\d{1,2}點半?$/,
  /^\d{1,2}:\d{2}$/,
  /^\d{1,2}點\d{0,2}分?$/
];

detectPureTimeInput("明天下午四點") → 直接拒絕
detectPureTimeInput("明天下午四點跆拳道") → 通過檢測，繼續處理
```

**Step 1: 規則引擎智能打分**
```javascript
// IntentRuleEngine 基於配置進行意圖識別
IntentRuleEngine.analyzeIntent("取消數學課")
→ { intent: 'cancel_course', confidence: 0.8 }

IntentRuleEngine.analyzeIntent("我想學點什麼")  
→ { intent: 'unknown', confidence: 0.0 }
```

**Step 2: 統一實體提取**
```javascript
// OpenAI優先的實體提取，正則表達式fallback
SemanticService.extractCourseEntities("明天下午四點半跆拳道")
→ { 
  course_name: "跆拳道", 
  timeInfo: {
    date: "2025-07-31",
    time: "16:30",
    confidence: 0.9
  }, 
  location: null 
}
```

**Step 3: 關鍵信心度測試**
```javascript
// 智能判斷：高信心度跳過AI，低信心度調用AI
if (ruleResult.confidence >= 0.8 && intent !== 'unknown') {
  return 規則引擎結果;  // 60-70% 案例，毫秒級響應
} else {
  return await OpenAI.analyzeIntent();  // 30-40% 案例，深度理解
}
```

### 效能統計

| 處理層級 | 案例比例 | 響應時間 | 準確率 | 成本 |
|---------|---------|----------|--------|------|
| **純時間攔截** | ~5% | <1ms | 100% | 免費 |
| **規則引擎** | ~60-70% | <10ms | 100% | 免費 |
| **OpenAI處理** | ~30-40% | 200-500ms | 95%+ | 付費 |

## 🎯 配置驅動開發

### 意圖規則配置 (`intent-rules.yaml`)
```yaml
# 意圖配置結構
intent_name:
  keywords: ['關鍵詞1', '關鍵詞2']    # 必要關鍵詞
  priority: 10                       # 優先級（數字越高越優先）
  exclusions: ['排除詞1', '排除詞2']  # 排除關鍵詞
  requires_context: false            # 是否需要上下文
```

### 場景配置開發
```yaml
# 配置文件結構
scenario_name: "場景名稱"
entity_type: "數據庫集合名稱"
entity_name: "顯示名稱"
required_fields: ["必要欄位1", "必要欄位2"]

# 訊息模板配置
messages:
  create_success: "✅ {entity_name}「{course_name}」已成功新增！"
  create_error: "❌ 新增{entity_name}失敗：{error_message}"
  
# 業務規則配置
business_rules:
  create:
    allow_duplicate_names: false
    auto_generate_missing_fields: true
```

### 訊息模板設計
```javascript
// 模板變數使用
const template = "✅ {entity_name}「{course_name}」已成功新增！\n🕒 時間：{schedule_time}";
const variables = {
  entity_name: "課程",
  course_name: "數學課",
  schedule_time: "07/31 4:30 PM"
};

// 渲染結果
"✅ 課程「數學課」已成功新增！\n🕒 時間：07/31 4:30 PM"
```

## 🐛 調試和測試

### 本地開發調試
```bash
# 啟動開發模式
npm run dev

# 查看日誌
npm run logs

# 執行測試
npm test

# 類型檢查
npm run type-check
```

### 生產環境調試
```bash
# 查看最近日誌
./scripts/get-app-logs.sh 50

# 搜索特定錯誤
./scripts/get-app-logs.sh 100 "ERROR"

# 按服務查詢
./scripts/get-app-logs.sh 30 "SemanticService"
./scripts/get-app-logs.sh 30 "TimeService"
./scripts/get-app-logs.sh 30 "TaskService"

# 按功能查詢
./scripts/get-app-logs.sh 50 "課程"
./scripts/get-app-logs.sh 30 "時間解析"
```

### 常見問題排查
```bash
# OpenAI 相關問題
./scripts/get-app-logs.sh 50 "OpenAI" 

# Firebase 連接問題
./scripts/get-app-logs.sh 30 "Firebase"

# LINE API 問題
./scripts/get-app-logs.sh 30 "LINE"

# 時間解析問題
./scripts/get-app-logs.sh 50 "parseTime"
```

## 📝 文檔和註釋規範

### 代碼註釋原則
```javascript
// ✅ 好的註釋：解釋為什麼
// 使用規則引擎處理高信心度意圖，避免不必要的 AI 調用
if (confidence >= 0.8) {
  return ruleResult;
}

// ❌ 不好的註釋：重複代碼內容
// 如果信心度大於等於 0.8
if (confidence >= 0.8) {
  return ruleResult;
}

// ✅ 好的註釋：重要的業務邏輯
// 課程時間衝突檢查：同一用戶在同一時間只能有一堂課
const hasConflict = await checkTimeConflicts(userId, dateTime);
```

### API 文檔格式
```javascript
/**
 * 分析用戶訊息並提取意圖和實體
 * @param {string} text - 用戶輸入文本
 * @param {Object} context - 對話上下文
 * @param {string} context.userId - 用戶 ID
 * @param {Array} context.history - 對話歷史
 * @returns {Promise<Object>} 分析結果
 * @returns {string} returns.intent - 識別的意圖
 * @returns {Object} returns.entities - 提取的實體
 * @returns {number} returns.confidence - 信心度 (0-1)
 */
async function analyzeMessage(text, context) {
  // 實現邏輯
}
```

## 🚀 部署前檢查清單

### 代碼品質檢查
- [ ] 所有修改遵循架構約束
- [ ] 沒有跨層直接調用
- [ ] 更新了 CHANGELOG.md
- [ ] 測試了主要功能路徑
- [ ] 檢查了錯誤處理

### 性能檢查
- [ ] 確認規則引擎優先級設置正確
- [ ] 檢查 OpenAI 調用是否必要
- [ ] 驗證緩存機制正常工作
- [ ] 確認數據庫查詢優化

### 安全檢查
- [ ] 環境變數配置正確
- [ ] API Keys 沒有洩露
- [ ] 用戶輸入驗證完整
- [ ] 錯誤信息不包含敏感數據